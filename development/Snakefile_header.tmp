from collections import defaultdict
from pathlib import Path
import os
import yaml

# Load default config
with open(Path(workflow.basedir) / "default.yaml") as f:
    merged_config = yaml.safe_load(f)

# Merge with user config (deep merge for 'path' dictionary)
# We store user overrides first
user_config = dict(config)
user_path = user_config.get("path", {})

# Apply user overrides to merged_config
for k, v in user_config.items():
    if k == "path" and isinstance(v, dict):
        merged_config["path"].update(v)
    elif k == "reference" and isinstance(v, dict):
        merged_config.setdefault("reference", {}).update(v)
    else:
        merged_config[k] = v

config = merged_config

# Flatten reference into top-level config for backward compatibility with rules
if "reference" in config:
    for k, v in config["reference"].items():
        if k not in config:
            config[k] = v

# Determine BATCH name
BATCH = config.get("batch", "dichromat_run")
IS_ETAM = config.get("is_etam", "eTAM" in BATCH)
SKIP_SAMPLES = config.get("skip_samples", [])

# Detect if we are running inside the dichromat container
INSIDE_CONTAINER = os.environ.get("PIPELINE_HOME") == "/pipeline"

# If running in a container, we should use the default tool names
# which are correctly set up in the container's PATH.
if config.get("container") or INSIDE_CONTAINER:
    # Revert 'path' to defaults if using a container
    with open(Path(workflow.basedir) / "default.yaml") as f:
        clean_defaults = yaml.safe_load(f)
        config["path"] = clean_defaults.get("path", {})


workdir: f"workspace_{BATCH}"

# Container directive for rules
# If already inside the container, we MUST set this to None to avoid nesting
container: None if INSIDE_CONTAINER else config.get("container")



REF = config.get("reference", {})
# Expand user paths in REF dictionary
for ref_type in REF:
    if isinstance(REF[ref_type], dict):
        for key, val in REF[ref_type].items():
            if isinstance(val, str):
                REF[ref_type][key] = os.path.expanduser(val)
    elif isinstance(REF[ref_type], list):
        REF[ref_type] = [os.path.expanduser(f) if isinstance(f, str) else f for f in REF[ref_type]]
    elif isinstance(REF[ref_type], str):
        REF[ref_type] = os.path.expanduser(REF[ref_type])


TEMPDIR = Path(
    os.path.relpath(
        config.get("tempdir", os.path.join(workflow.basedir, ".tmp")), workflow.basedir
    )
)
PATH = config.get("path", {})

INTERNALDIR = Path("internal_files")
MARKDUP = config.get("markdup", True)
SPLICE_GENOME = config.get("splice_genome", True)
SPLICE_CONTAM = config.get("splice_contamination", False)


wildcard_constraints:
    sample=r"[^/_\.]+",
    rn=r"run[0-9]+",


SAMPLE2DATA = defaultdict(lambda: defaultdict(dict))
GROUP2SAMPLE = defaultdict(list)
SAMPLE2LIB = defaultdict(str)
SAMPLE2ADP = defaultdict(str)

# Support both 'samples' and 'samples_{BATCH}' for compatibility
samples_dict = config.get("samples") or config.get(f"samples_{BATCH}")
if not samples_dict:
    raise SystemExit(f"Please add 'samples' or 'samples_{BATCH}' in your config file")

for s, v in samples_dict.items():
    s = str(s)
    SAMPLE2LIB[s] = v.get("libtype", config.get("libtype", "")) # Built-in Name
    SAMPLE2ADP[s] = v.get("adapter", config.get("adapter", "")) # Custom Sequence
    if "group" in v:
        GROUP2SAMPLE[v["group"]].append(s)
    for i, v2 in enumerate(v["data"], 1):
        r = f"run{i}"
        SAMPLE2DATA[str(s)][r] = {
            k: os.path.expanduser(v3) for k, v3 in dict(v2).items()
        }

HAS_GENES = bool(config.get("genes"))
HAS_CONTAM = bool(config.get("contamination"))

REFTYPES = (
    (["contamination"] if HAS_CONTAM else [])
    + (["genes"] if HAS_GENES else [])
    + ["transcript", "genome"]
)


def is_pe(sample, rn):
    return len(SAMPLE2DATA[sample][rn]) == 2


def get_lib_subdir(sample, rn):
    return "PE" if is_pe(sample, rn) else "SE"


SRCDIR = Path(workflow.basedir) / "src"


rule all:
    input:
        "report_reads/mapping.html",
        "report_reads/trimmed.html",
        "report_reads/unmapped.html",
